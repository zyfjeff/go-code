MapReduce:
    抽象出一个Map接口和一个Reduce接口，屏蔽底层的基础设施的细节，让使用者可以轻松的编写分布式的应用。

分为两个阶段:
    Map:
        doMap阶段主要是将用户输入的文件，分成N份，对于每一份文件读取其内容回调用户的Map函数得到输出，根据输出的
        key进行hash，然后对reduce的个数进行取模得到要输出给哪个reduce，然后根据这个reduce的index得到输出文件名
        最终把这个key输出到这个文件中。

    Reduce:
        doReduce阶段会从每一个doMap的work中拿到输出的文件名，然后打开这个文件读取内容回调用户的reduce函数，得到
        输出，然后排序最终写入到输出的文件名。

需要考虑的问题:
1.输入的数据如何分割
2.大量计算机组成的集群如何调度
3.集群中的计算机发生了错误如何处理
4.如何管理集群中的计算机之间的通信

容错处理:
    周期性的去ping worker，固定时间没有收到响应就把这个worker标记失效，把这个worker完成的任务也设置为初始空闲状态
    等待重新调度，因为map的输出是在本地，而已经完成的reducer任务不需要重新的调度，因为reduce的输出在全局文件系统上

master故障:
    master定期写入checkpoint

* 通过原子的重命名操作老保证所有的reduce最终值产生一个输出的文件名
* 通过将输入文件放在本地来减少网络带宽的消耗
* 输入文件被分成多个block，每一个block会被拷贝到其他机器上N份，起到副本的作用
* 备用任务机制处理集群中出现的"落伍者"，当一个MapReduce任务接近完成的时候，master调度备用任务进程来执行剩下的处于
    中间状态的任务。无论是最初的进程还是备用任务进程完成了任务都会把任务标记为完成。
* 通过本地combiner将重复的数据进行合并，减少了对网络带宽的消耗。
* 跳过损坏的记录，通过捕捉内存段异常，总线错误的信号，在信号处理函数中用最后一口气通过UDP向master发送最后处理的记录

